name: Manual workflow to transfer docker images

on:
  workflow_call:
    inputs:
      USERNAME:
        description: 'Provide registry username (e.g. robot$mosipdev+mosipdev for Harbor)'
        required: true
        default: ''
        type: string
      DESTINATION_ORGANIZATION:
        description: 'Provide Docker Hub destination org'
        required: true
        default: ''
        type: string
      REGISTRY_URL:
        description: 'Provide destination registry URL'
        required: true
        default: 'http://10.0.3.128:8080'
        type: string
      REGISTRY_TYPE:
        description: 'Registry type (dockerhub, harbor, other)'
        required: true
        default: 'harbor'
        type: string
      ENABLE_WIREGUARD:
        description: 'Enable WireGuard VPN for private networks'
        required: false
        default: false
        type: boolean
    secrets:
      TOKEN:
        description: 'Provide registry token'
        required: true
      SLACK_WEBHOOK_URL:
        required: true
      WIREGUARD_CONFIG:
        description: 'WireGuard VPN configuration'
        required: false

jobs:
  Image-transfer:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: Install WireGuard
        run: sudo apt-get update && sudo apt-get install -y wireguard
        if: ${{ inputs.ENABLE_WIREGUARD == true }}

      - name: Configure WireGuard
        run: |
          # WireGuard config comes from secrets
          if [ -z "${{ secrets.WIREGUARD_CONFIG }}" ]; then
            echo "‚ùå ERROR: WIREGUARD_CONFIG secret is not configured"
            echo "Please configure the WireGuard configuration secret for Harbor VPN access"
            exit 1
          fi
          
          # Debug: Check if secret is available (without exposing content)
          echo "üîç Checking WIREGUARD_CONFIG secret..."
          if [ ${#WIREGUARD_CONFIG} -eq 0 ]; then
            echo "‚ùå ERROR: WIREGUARD_CONFIG environment variable is empty"
            exit 1
          fi
          echo "‚úÖ Secret length: ${#WIREGUARD_CONFIG} characters"
          
          # Create config file with proper handling
          echo "Creating /etc/wireguard directory with proper permissions..."
          sudo mkdir -p /etc/wireguard
          sudo chmod 755 /etc/wireguard
          sudo chown root:root /etc/wireguard
          
          # Debug: Check secret format without exposing sensitive data
          echo "Secret contains '[Interface]': $(printf '%s' "$WIREGUARD_CONFIG" | grep -c '\[Interface\]')"
          echo "Secret contains '[Peer]': $(printf '%s' "$WIREGUARD_CONFIG" | grep -c '\[Peer\]')"
          
          # Write to temp file with explicit newline handling
          printf '%s' "$WIREGUARD_CONFIG" > /tmp/wg0.conf.tmp
          
          # Check temp file was created successfully
          if [ ! -f /tmp/wg0.conf.tmp ]; then
            echo "‚ùå ERROR: Failed to create temporary config file"
            exit 1
          fi
          
          echo "Temp file size: $(wc -c < /tmp/wg0.conf.tmp) bytes"
          echo "Temp file lines: $(wc -l < /tmp/wg0.conf.tmp)"
          
          # Write config directly with sudo
          echo "Writing config directly with sudo..."
          sudo tee /etc/wireguard/wg0.conf < /tmp/wg0.conf.tmp > /dev/null
          
          # Clean up temp file
          rm -f /tmp/wg0.conf.tmp
          
          # Verify the file was created and check its size
          if sudo test -f /etc/wireguard/wg0.conf; then
            echo "‚úÖ Config file created successfully"
            echo "Final config file size: $(sudo wc -c < /etc/wireguard/wg0.conf) bytes"
          else
            echo "‚ùå ERROR: Config file still doesn't exist"
            sudo ls -la /etc/wireguard/ || echo "Cannot list /etc/wireguard directory"
            exit 1
          fi
          
          # Set proper permissions
          sudo chmod 600 /etc/wireguard/wg0.conf
          sudo chown root:root /etc/wireguard/wg0.conf
          
          echo "Final file permissions: $(sudo ls -la /etc/wireguard/wg0.conf)"
          
          # Verify config file is not empty and has expected content
          if ! sudo test -s /etc/wireguard/wg0.conf; then
            echo "‚ùå ERROR: WireGuard config file is empty after writing!"
            exit 1
          fi
          
          # Basic validation that it looks like a WireGuard config
          if ! sudo grep -q "\[Interface\]" /etc/wireguard/wg0.conf; then
            echo "‚ùå ERROR: WireGuard config doesn't contain [Interface] section"
            echo "Please check that WIREGUARD_CONFIG contains a valid WireGuard configuration"
            exit 1
          fi
          
          echo "‚úÖ WireGuard configuration applied successfully"
          echo "Config file size: $(sudo wc -c < /etc/wireguard/wg0.conf) bytes"
        env:
          WIREGUARD_CONFIG: ${{ secrets.WIREGUARD_CONFIG }}
        if: ${{ inputs.ENABLE_WIREGUARD == true }}

      - name: Start WireGuard
        run: |
          sudo chmod 600 /etc/wireguard/wg0.conf
          sudo chmod 700 /etc/wireguard/
          sudo systemctl daemon-reload
          echo "Starting WireGuard VPN..."
          if ! sudo wg-quick up wg0; then
            echo "‚ùå ERROR: Failed to start WireGuard VPN"
            echo "Config file contents (first 5 lines):"
            sudo head -5 /etc/wireguard/wg0.conf
            exit 1
          fi
          echo "‚úÖ WireGuard VPN started successfully"
          sudo wg show wg0
          echo "‚úÖ VPN connection established - Harbor registry should now be accessible"
        if: ${{ inputs.ENABLE_WIREGUARD == true }}
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install crane tool for multi-arch image transfers
        run: |
          # Install crane (Apache 2.0 License - Open Source)
          # From Google's go-containerregistry project
          curl -sL https://github.com/google/go-containerregistry/releases/latest/download/go-containerregistry_Linux_x86_64.tar.gz | sudo tar -xzC /usr/local/bin crane
          crane version
          echo "‚úÖ Crane installed successfully (Open Source - Apache 2.0)"
          
      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip
          pip install docker requests urllib3 PyYAML
          pip show docker
          echo "‚úÖ Python dependencies installed"
          
      - name: Configure Docker for insecure registries
        run: |
          # Configure Docker daemon for HTTP registries like Harbor
          REGISTRY_HOST=$(echo "${{ inputs.REGISTRY_URL }}" | sed 's|http://||' | sed 's|https://||' | cut -d'/' -f1)
          echo "Configuring Docker for registry: $REGISTRY_HOST"
          
          # Create or update Docker daemon configuration
          sudo mkdir -p /etc/docker
          
          # Check if URL starts with https:// (proper bash syntax)
          if [[ "${{ inputs.REGISTRY_URL }}" != https://* ]]; then
            echo "Adding insecure registry configuration for HTTP registry"
            echo '{
              "insecure-registries": ["'$REGISTRY_HOST'"]
            }' | sudo tee /etc/docker/daemon.json
            
            # Restart Docker daemon
            sudo systemctl restart docker
            sleep 5
          else
            echo "‚úÖ HTTPS registry detected - no insecure configuration needed"
          fi
          
          echo "‚úÖ Docker configured for registry operations"
          
      - name: Update config.yml with dynamic registry detection
        run: |
          cd release/vidivi
          echo "PWD: $(pwd)"
          echo "LS: $(ls)"
          
          # Update config.yml with provided values
          # USERNAME is now a regular input, not a secret - no shell escaping issues!
          USERNAME='${{ inputs.USERNAME }}'
          TOKEN='${{ secrets.TOKEN }}'
          DESTINATION_ORG='${{ inputs.DESTINATION_ORGANIZATION }}'
          REGISTRY_URL='${{ inputs.REGISTRY_URL }}'
          
          echo "üîç USERNAME provided: $USERNAME"
          
          # Update config using variables (prevents $ and other special chars from being interpreted)
          sed -i "s|username:.*|username: ${USERNAME}|g" config.yml
          sed -i "s|token:.*|token: ${TOKEN}|g" config.yml
          sed -i "s|destination_organization:.*|destination_organization: ${DESTINATION_ORG}|g" config.yml
          sed -i "s|registry_url:.*|registry_url: ${REGISTRY_URL}|g" config.yml
          
          echo "‚úÖ Updated config.yml:"
          cat config.yml
          
          # Debug: Check if $ is preserved in config.yml
          echo "üîç Checking username in config.yml:"
          grep "username:" config.yml
          echo "‚úÖ Username contains '\$': $(grep 'username:.*\$' config.yml && echo 'YES' || echo 'NO')"
          
      - name: Login to destination registry
        run: |
          REGISTRY_TYPE="${{ inputs.REGISTRY_TYPE }}"
          REGISTRY_URL="${{ inputs.REGISTRY_URL }}"
          
          echo "Registry Type: $REGISTRY_TYPE"
          echo "Registry URL: $REGISTRY_URL"
          
          if [ "$REGISTRY_TYPE" = "dockerhub" ]; then
            # Login to Docker Hub
            echo "Logging in to Docker Hub..."
            echo "${{ secrets.TOKEN }}" | docker login -u "${{ inputs.USERNAME }}" --password-stdin
            echo "‚úÖ Docker Hub login successful"
            
          elif [ "$REGISTRY_TYPE" = "harbor" ] || [ "$REGISTRY_TYPE" = "other" ]; then
            # Login to Harbor or other private registry
            REGISTRY_HOST=$(echo "$REGISTRY_URL" | sed 's|http://||' | sed 's|https://||' | cut -d'/' -f1)
            echo "Logging in to registry: $REGISTRY_HOST"
            
            # Test connectivity first (especially important for VPN-connected registries)
            echo "Testing connectivity to $REGISTRY_HOST..."
            
            # Extract hostname and port (default to 443 for https, 80 for http)
            if [[ "$REGISTRY_HOST" == *:* ]]; then
              # Port is explicitly specified
              REGISTRY_HOSTNAME="${REGISTRY_HOST%:*}"
              REGISTRY_PORT="${REGISTRY_HOST##*:}"
            else
              # No port specified, use defaults
              REGISTRY_HOSTNAME="$REGISTRY_HOST"
              if [[ "$REGISTRY_URL" == https://* ]]; then
                REGISTRY_PORT="443"
              else
                REGISTRY_PORT="80"
              fi
            fi
            
            echo "Testing connection to $REGISTRY_HOSTNAME:$REGISTRY_PORT..."
            if ! timeout 10 nc -z "$REGISTRY_HOSTNAME" "$REGISTRY_PORT" 2>/dev/null; then
              echo "‚ö†Ô∏è  WARNING: Cannot connect to $REGISTRY_HOSTNAME:$REGISTRY_PORT - registry may not be accessible"
              if [ "${{ inputs.ENABLE_WIREGUARD }}" = "true" ]; then
                echo "üí° WireGuard is enabled - checking VPN status..."
                sudo wg show wg0 || echo "‚ùå WireGuard interface not active"
              fi
              echo "‚ö†Ô∏è  Proceeding with login attempt anyway..."
            else
              echo "‚úÖ Registry connectivity confirmed"
            fi
            
            # Login to private registry
            echo "üîê Attempting login to $REGISTRY_HOST..."
            
            # Debug: Check credentials format
            USERNAME='${{ inputs.USERNAME }}'
            TOKEN='${{ secrets.TOKEN }}'
            echo "Username: $USERNAME"
            echo "Token length: ${#TOKEN}"
            
            # Try login with explicit error handling
            if echo "$TOKEN" | docker login $REGISTRY_HOST -u "$USERNAME" --password-stdin 2>&1 | tee /tmp/docker_login.log; then
              echo "‚úÖ Private registry login successful"
            else
              echo "‚ùå Login failed. Error details:"
              cat /tmp/docker_login.log
              
              echo ""
              echo "üîç Debugging information:"
              echo "- Registry: $REGISTRY_HOST"
              echo "- Username: $USERNAME"
              echo "- Username format: Harbor robot accounts should be: robot\$project+name"
              echo ""
              echo "üí° Common issues:"
              echo "1. Username should be: robot\$mosipdev+robotname (not robot+mosipdev)"
              echo "2. Token must be the robot account token from Harbor"
              echo "3. Robot account must have push/pull permissions on mosipdev project"
              echo ""
              echo "üß™ Manual test command (run locally):"
              echo "echo 'YOUR_TOKEN' | docker login harbor.mosip.net -u '$USERNAME' --password-stdin"
              
              exit 1
            fi
            
          else
            echo "‚ùå ERROR: Unsupported registry type: $REGISTRY_TYPE"
            echo "Supported types: dockerhub, harbor, other"
            exit 1
          fi
          
      - name: Transfer images with multi-arch support
        run: |
          cd release/vidivi
          echo "üöÄ Starting image transfer with crane multi-arch support..."
          
          # Run vidivi with enhanced logging
          python3 vidivi.py push 2>&1 | tee transfer.log
          
          # Display summary
          echo "üìä Transfer Summary:"
          grep -E "(Successfully transferred|Error in|Completed)" logs/vidivi.log | tail -20 || echo "No summary available"
          
      - name: Verify multi-arch transfers
        run: |
          cd release/vidivi
          echo "üîç Verifying multi-arch transfers..."
          
          # Check if crane transfers were successful
          CRANE_SUCCESS=$(grep -c "Successfully transferred multi-arch manifest list with crane" logs/vidivi.log || echo "0")
          TOTAL_SUCCESS=$(grep -c "Completed.*----->" logs/vidivi.log || echo "0")
          
          echo "‚úÖ Multi-arch transfers (crane): $CRANE_SUCCESS"
          echo "‚úÖ Total successful transfers: $TOTAL_SUCCESS"
          
          # List successful crane transfers
          if [ "$CRANE_SUCCESS" -gt 0 ]; then
            echo "üöÄ Multi-arch images transferred:"
            grep -B5 "Successfully transferred multi-arch manifest list with crane" logs/vidivi.log | grep "Executing: crane" | sed 's/.*crane copy [^[:space:]]* //' | sed 's/ .*//' || echo "Could not extract image list"
          fi
          
      - name: Generate transfer report
        run: |
          cd release/vidivi
          echo "üìã Generating transfer report..."
          
          # Create summary report
          cat > transfer_report.md << EOF
          # Image Transfer Report
          
          **Date**: $(date)
          **Registry Type**: ${{ inputs.REGISTRY_TYPE }}
          **Registry URL**: ${{ inputs.REGISTRY_URL }}  
          **Organization**: ${{ inputs.DESTINATION_ORGANIZATION }}
          **WireGuard VPN**: ${{ inputs.ENABLE_WIREGUARD && 'Enabled' || 'Disabled' }}
          
          ## Statistics
          - **Multi-arch transfers (crane)**: $(grep -c "Successfully transferred multi-arch manifest list with crane" logs/vidivi.log || echo "0")
          - **Total successful transfers**: $(grep -c "Completed.*----->" logs/vidivi.log || echo "0")
          - **Failed transfers**: $(grep -c "ERROR.*Failed to get manifest\|ERROR.*does not exist\|ERROR.*Crane transfer failed" logs/vidivi.log || echo "0")
          
          ## Tools Used
          - ‚úÖ Crane (Apache 2.0): Multi-arch manifest list transfers
          - ‚úÖ Docker Python Client: Single-arch fallback transfers
          - ‚úÖ Registry Support: HTTP/HTTPS auto-detection
          
          ## Crane Multi-Arch Images
          EOF
          
          # Add crane transfer details
          grep -B5 "Successfully transferred multi-arch manifest list with crane" logs/vidivi.log | grep "Executing: crane" | sed 's/.*crane copy [^[:space:]]* /- /' | sed 's/ .*//' >> transfer_report.md || echo "- No crane transfers found" >> transfer_report.md
          
          echo "‚úÖ Transfer report generated"
          cat transfer_report.md
          
      - name: Commit and push vidivi log
        run: |
          cd release/vidivi/logs/
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Add logs and report
          git add .
          cd ..
          git add transfer_report.md || echo "No report to add"
          
          # Commit with detailed message
          CRANE_COUNT=$(grep -c "Successfully transferred multi-arch manifest list with crane" logs/vidivi.log || echo "0")
          TOTAL_COUNT=$(grep -c "Completed.*----->" logs/vidivi.log || echo "0")
          
          git commit -m "Image transfer completed: $TOTAL_COUNT total, $CRANE_COUNT multi-arch (crane) to ${{ inputs.DESTINATION_ORGANIZATION }}" || echo "No changes to commit"
          git push || echo "Push failed or no changes"

      - name: Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,author,commit,workflow,job
          text: |
            Image Transfer ${{ job.status }}!
            Registry Type: ${{ inputs.REGISTRY_TYPE }}
            Registry URL: ${{ inputs.REGISTRY_URL }}
            Organization: ${{ inputs.DESTINATION_ORGANIZATION }}
            WireGuard VPN: ${{ inputs.ENABLE_WIREGUARD && 'Enabled' || 'Disabled' }}
            Multi-arch transfers: $(grep -c "Successfully transferred multi-arch manifest list with crane" release/vidivi/logs/vidivi.log || echo "0")
            Total transfers: $(grep -c "Completed.*----->" release/vidivi/logs/vidivi.log || echo "0")
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()
